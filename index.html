<!DOCTYPE html>
<script type="text/javascript" src='/vendor/three.js/build/three.js'></script>
<script type="text/javascript" src="/vendor/require.js/require.js"></script>
<script type="text/javascript" src="/vendor/three.js/examples/js/Detector.js"></script>
<script type="text/javascript" src="/vendor/three.js/examples/js/libs/stats.min.js"></script>
<script type="text/javascript" src="/vendor/three.js/examples/js/controls/OrbitControls.js"></script>
<script type="text/javascript" src="/vendor/threex.windowresize.js"></script>

<body style='margin: 0px; background-color: #bbbbbb; overflow: hidden;'><script>
require([], function(){
	//////////////////////////////////////////////////////////////////////////////////
	//		main					//
	//////////////////////////////////////////////////////////////////////////////////	
	var scene, camera, renderer, stats, controls;
	var geometry, material, mesh;
	var shape, cover, ball, box;
	var container = document.body;

	// set the view size in pixels (custom or according to window size)
	// var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;	
	// camera attributes
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;

	initScene();
	initCamera();
	initRenderer();
	initLighting();

	var winResize	= new THREEx.WindowResize(renderer, camera);

	initGeometry();
	initStats();
	initControls();
	
 	makeFloor();

	makePlinth( 300,  300);
	makePlinth(-300,  300);
	makePlinth( 300, -300);
	makePlinth(-300, -300);

	animate();

	function initScene() {
		scene = new THREE.Scene();
	}

	function initCamera() {
		// set up camera
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		// add the camera to the scene
		scene.add(camera);
		// the camera defaults to position (0,0,0)
		// so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
		camera.position.set(0,150,400);
		camera.lookAt(scene.position);

		// setup a scene and camera
		// var camera	= new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
		// scene.add(camera);
		// camera.position.z = 500;
	}

	function initRenderer() {
		// create and start the renderer; choose antialias setting.
		if ( Detector.webgl ) {
			renderer = new THREE.WebGLRenderer( {antialias:true} );
			console.log("Running WebGL. Cool.");
		} else {
			renderer = new THREE.CanvasRenderer();
			console.log("Running Canvas. Lees cool.");
		}
		renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		
		// attach div element to variable to contain the renderer
		// container = document.getElementById( 'ThreeJS' );
		// alternatively: to create the div at runtime, use:
		//   container = document.createElement( 'div' );
		//    document.body.appendChild( container );
		
		// attach renderer to the container div
		container.appendChild( renderer.domElement );
	}

	function initLighting() {
		// var ambientLight= new THREE.AmbientLight( 0x020202 );
		// scene.add( ambientLight);
		// var frontLight	= new THREE.DirectionalLight('white', 1);
		// frontLight.position.set(0.5, 0.5, 2);
		// scene.add( frontLight );
		// var backLight	= new THREE.DirectionalLight('white', 0.75);
		// backLight.position.set(-0.5, -0.5, -2);
		// scene.add( backLight );

		// create a light
		var light = new THREE.PointLight(0xffffff);
		light.position.set(0,250,0);
		scene.add(light);
		var ambientLight = new THREE.AmbientLight(0x111111);
		scene.add(ambientLight);
	}
  
	function initGeometry() {
		console.log("initGeometry");

		// most objects displayed are a "mesh":
		//  a collection of points ("geometry") and
		//  a set of surface parameters ("material")	

		// Sphere parameters: radius, segments along width, segments along height
		var sphereGeometry = new THREE.SphereGeometry( 30, 32, 16 ); 
		// use a "lambert" material rather than "basic" for realistic lighting.
		//   (don't forget to add (at least one) light!)
		var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0x8888ff} ); 
		var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		sphere.position.set(100, 30, -50);
		scene.add(sphere);
		
		// Create an array of materials to be used in a cube, one for each side
		var cubeMaterialArray = [];
		// order to add materials: x+,x-,y+,y-,z+,z-
		cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0xff3333 } ) );
		cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0xff8800 } ) );
		cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0xffff33 } ) );
		cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x33ff33 } ) );
		cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x3333ff } ) );
		cubeMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x8833ff } ) );
		var cubeMaterials = new THREE.MeshFaceMaterial( cubeMaterialArray );
		// Cube parameters: width (x), height (y), depth (z), 
		//        (optional) segments along x, segments along y, segments along z
		var cubeGeometry = new THREE.CubeGeometry( 60, 60, 60, 1, 1, 1 );
		// using THREE.MeshFaceMaterial() in the constructor below
		//   causes the mesh to use the materials stored in the geometry
		cube = new THREE.Mesh( cubeGeometry, cubeMaterials );
		cube.position.set(-100, 30, -50);
		scene.add( cube );		

		// create a set of coordinate axes to help orient user
		//    specify length in pixels in each direction
		var axes = new THREE.AxisHelper(100);
		scene.add( axes );

		// msp
		// geometry = new THREE.IcosahedronGeometry(200, 1);
		// material = new THREE.MeshBasicMaterial({
		//   color: 0x000000,
		//   wireframe: true,
		//   wireframeLinewidth: 1
		// });

		// mesh = new THREE.Mesh(geometry, material);
		// scene.add(mesh);
		// mesh.position.set(0,0,-500);

		// shape = new THREE.SphereGeometry(100);
		// cover = new THREE.MeshNormalMaterial();
		// ball = new THREE.Mesh(shape, cover);
		// scene.add(ball);
		// ball.position.set(0,0,-500);

		// shape = new THREE.CubeGeometry(100, 100, 100);
		// box = new THREE.Mesh(shape, cover);
		// box.position.set(200,100,0);
		// // scene.add(box);
		// box.rotation.set(0.5, 0.5, 0);

		console.log("done initGeometry");
	}

	function initStats() {
		// displays current and past frames per second attained by scene
		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.bottom = '0px';
		stats.domElement.style.zIndex = 100;
		document.body.appendChild(stats.domElement);
	}

	function initControls() {
		// move mouse and: left   click to rotate, 
		//                 middle click to zoom, 
		//                 right  click to pan
		controls = new THREE.OrbitControls( camera, renderer.domElement );
	}

	function makeFloor() {
		// note: 4x4 checkboard pattern scaled so that each square is 25 by 25 pixels.
		var floorTexture = new THREE.ImageUtils.loadTexture( '/images/checkerboard.jpg' );
		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
		floorTexture.repeat.set( 10, 10 );
		// DoubleSide: render texture on both sides of mesh
		var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
		var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -0.5;
		floor.rotation.x = Math.PI / 2;
		scene.add(floor);
	}

	function makePlinth(x, z) { 
		var base = new THREE.Mesh(new THREE.CubeGeometry(50, 200, 50), new THREE.MeshLambertMaterial( {color: 0x8888ff} ) );
		base.position.set(x, 50, z);
		scene.add(base);
	}

	function animate() {
		requestAnimationFrame(animate);

		// mesh.rotation.x = Date.now() * 0.0005;
		// mesh.rotation.y = Date.now() * 0.001;
		// camera.position.z = camera.position.z + 0.5;
		// camera.position.y = camera.position.y + 1;
		// mesh.rotation.x = mesh.rotation.x + 0.05;
		render();		
		update();
	}

	function update() {
		// delta = change in time since last call (in seconds)
		// var delta = clock.getDelta(); 			
		// controls.update();
		stats.update();
	}

	function render() {	
		renderer.render(scene, camera);
	}

	
	// onRenderFcts.push(function(delta, now){
	// 	// mesh.rotateX(0.5 * delta);
	// 	// mesh.rotateY(2.0 * delta);
	// 	// sphere.rotateX(0.5 * delta);
	// 	// sphere.rotateY(2.0 * delta);		
	// })
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Camera Controls							//
	//////////////////////////////////////////////////////////////////////////////////
	// var mouse	= {x : 0, y : 0}
	// document.addEventListener('mousemove', function(event){
	// 	mouse.x	= (event.clientX / window.innerWidth ) - 0.5;
	// 	mouse.y	= (event.clientY / window.innerHeight) - 0.5;
	// }, false)
	// onRenderFcts.push(function(delta, now){
	// 	camera.position.x += (mouse.x*1000 - camera.position.x) * (delta*3);
	// 	camera.position.y += (mouse.y*1000 - camera.position.y) * (delta*3);
	// 	camera.lookAt( scene.position );
	// })

	//////////////////////////////////////////////////////////////////////////////////
	//		render the scene						//
	//////////////////////////////////////////////////////////////////////////////////
	// onRenderFcts.push(function(){
	// 	renderer.render( scene, camera );		
	// })
	
	//////////////////////////////////////////////////////////////////////////////////
	//		Rendering Loop runner						//
	//////////////////////////////////////////////////////////////////////////////////
	// var lastTimeMsec= null
	// requestAnimationFrame(function animate(nowMsec){
	// 	// keep looping
	// 	requestAnimationFrame( animate );
	// 	// measure time
	// 	lastTimeMsec	= lastTimeMsec || nowMsec-1000/60;
	// 	var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec);
	// 	lastTimeMsec	= nowMsec;
	// 	// call each update function
	// 	onRenderFcts.forEach(function(onRenderFct){
	// 		onRenderFct(deltaMsec/1000, nowMsec/1000);
	// 	})
	// })
})
</script></body>
